---
title: 【ES6】Class：通过原型创建对象和通过Class创建对象
date: 2018.11.21 12:00:00
categories:
  - 技术篇
tags:
  - 前端
  - JavaScript
  - ES6
---

## 一、ES5
1. 在实例中定义了与原型同名的属性，只是阻断了对原型中属性的访问，而并没有也不能修改原型中的属性。
2. 在 `for-in` 循环时，返回“可枚举”的属性，不管在实例中还是原型中。第一，根据规定，所有开发人员定义的属性都是可枚举的。第二、数据属性 `[[Enumerable]]` 为 `false`的属性都是不可枚举的。第三、默认不可枚举的属性和方法有：`constructor`、`prototype`、`hasOwnProperty()`、`propertyIsEnumerable()`、`toLocaleString()`、`toString()`、`valueOf()`，即这些方法的数据属性 `[[Enumerable]]` 默认为 `false`。
3. 无论属性存在于实例还是存在于原型中，使用 `in` 都会返回 `true`，但是 `hasOwnProperty` 方法只有在属性存在于 实例中才返回 `true`，那么结合这两个方法就能判断 属性是不是存在于原型中。

## 二、ES6
1. 类的内部所有定义的方法，都是不可枚举的（`non-enumerable`），但是可以将方法定义在 `constructor` 内就可以枚举了。也就是说 定义在 `class` 内（`construct` 外）的方法 都相当于定义在 ES5 中 构造函数 `Function.prototype` 里的，而定义在 `construct` 里的属性和方法都是 属于 `new` 出来的实例本身具有的属性和方法。说白了跟 ES5 还是“一模一样”的。
2. 必须使用 `new` 方法调用，否则会报错。这样比 ES5 更安全（ES5 的构造函数就是普通函数，直接调用的话，里边的 `this` 就指向了 全局，极有可能污染全局变量）。
3. 采用 `Class` 表达式，可以写出立即执行的 `Class`。
4. 类的定义不存在变量提升。
5. 关于设定私有属性，我推荐利用 `Symbol` 值的唯一性，将私有方法的名字命名为一个 `Symbol` 值。（不推荐 ES5 的骚操作，新的提案暂时忽略）
6. (1)类的方法内部如果含有 `this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。(2)一个比较简单的解决方法是，在构造方法中绑定 `this`，另一种解决方法是使用箭头函数。还有一种解决方法是使用 `Proxy`，获取方法的时候，自动绑定 `this`。
7. 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 `Class` 继承，包括 `name` 属性。
8. (1)如果在一个方法前，加上 `static` 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。(2)静态方法包含的 `this` 关键字指的是类。(3)静态方法可以与非静态方法重名。(4)父类的静态方法，可以被子类继承。静态方法也是可以从 `super` 对象上调用的。
9. `Class` 内部调用 `new.target`，返回当前 `Class`。需要注意的是，子类继承父类时，`new.target` 会返回子类。

## 三、Class 的继承
1. 子类必须在 `constructor` 方法中调用 `super` 方法，否则新建实例时会报错。这是因为子类自己的 `this` 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super` 方法，子类就得不到 `this` 对象。
2. `Object.getPrototypeOf` 方法可以用来从子类上获取父类。
3. `super` 虽然代表了父类的构造函数，但是返回的是子类的实例。
4. `super` 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。
5. `super` 作为函数调用时，代表父类的构造函数。并且只能用在子类的构造函数之中。
6. `super` 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
7. 由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 `super` 关键字。
8. 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类。
9. 子类 `prototype` 属性的 `__proto__` 属性，表示方法的继承，总是指向父类的 `prototype` 属性。
10. 子类实例的 `__proto__` 属性的 `__proto__` 属性，指向父类实例的 `__proto__` 属性。也就是说，子类的原型的原型，是父类的原型。
11. ES5 不能实现原生构造函数的继承，ES6 的 `extends` 可以。